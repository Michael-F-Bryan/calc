use syntax::ast::{Expr, Atom, BinaryOp, FunctionCall};

grammar;

pub Expr: Expr = {
    <l:Expr> "+" <r:Factor> => BinaryOp::add(l, r).into(),
    <l:Expr> "-" <r:Factor> => BinaryOp::sub(l, r).into(),
    Factor,
};

Factor: Expr = {
    <l:Factor> "*" <r:Atom> => BinaryOp::mult(l, r.into()).into(),
    <l:Factor> "/" <r:Atom> => BinaryOp::div(l, r.into()).into(),
    <f:FunctionCall> => f.into(),
    <a:Atom> => a.into(),
};

pub FunctionCall: FunctionCall = {
    <i:ident> "(" <a:CommaSeparated<Expr>> ")" => FunctionCall::new(i, a),
};

pub Atom: Atom = {
    <s:r"[0-9]+(\.[0-9]+)?"> => Atom::Number(s.parse().unwrap()),
    <i:ident> => Atom::Ident(i),
};

ident: String = {
    <i:r"[a-zA-Z][a-zA-Z0-9_-]*"> => i.to_string(),
};

CommaSeparated<T>: Vec<T> = { 
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};