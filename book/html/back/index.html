<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Converting to LLVM IR - Rusty Calc</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="parse/index.html"><strong aria-hidden="true">2.</strong> Parsing</a></li><li><ol class="section"><li><a href="parse/setup.html"><strong aria-hidden="true">2.1.</strong> Setting Up The Project</a></li><li><a href="parse/grammar.html"><strong aria-hidden="true">2.2.</strong> The Language Grammar</a></li><li><a href="parse/ast.html"><strong aria-hidden="true">2.3.</strong> The Abstract Syntax Tree</a></li><li><a href="parse/write_grammar.html"><strong aria-hidden="true">2.4.</strong> Writing grammar.lalrpop</a></li><li><a href="parse/visit.html"><strong aria-hidden="true">2.5.</strong> Creating an AST Visitor</a></li></ol></li><li><a href="back/index.html" class="active"><strong aria-hidden="true">3.</strong> Converting to LLVM IR</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">Rusty Calc</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="back/index.html#converting-to-llvm-ir" id="converting-to-llvm-ir"><h1>Converting to LLVM IR</h1></a>
<p>Now we've got a more computer-friendly representation of our program we need
to convert it to LLVM's Intermediate Representation. This IR can come in several
forms, a human-readable &quot;assembly&quot;, a compiled bitcode, or an in-memory tree of
objects (similar to our current AST).</p>
<p>LLVM uses the <a href="http://llvm.org/doxygen/classllvm_1_1Module.html#details"><code>Module</code></a> as its base compilation unit (think of it as a single
<code>*.c</code> file), with a <code>Module</code> containing several functions, datatypes, constants,
or global variables.</p>
<p>Because our simple calculator doesn't allow you to declare functions, we're
going to throw everything into one big main function with the signature
<code>fn calc_main() -&gt; f64</code>. This way when we JIT compile the program we can call
into the <code>calc_main()</code> function to execute everything. It also means it's quite
trivial to compile the program into a shared library (<code>*.so</code> or DLL) so other
programs can call it.</p>
<p>This conversion process is done by recursively walking the parsed AST, turning
each node into the corresponding LLVM instruction(s).</p>
<p>Later on, the <code>Visitor</code> trait will be used to do some minor type-checking by
looking for variables uses/assignments and function calls.</p>
<a class="header" href="back/index.html#the-compiler-struct" id="the-compiler-struct"><h2>The Compiler Struct</h2></a>
<p>LLVM uses a <code>Context</code> for the various internal states and variables involved
during the compilation process, which we'll encapsulate in a <code>Compiler</code> struct.</p>
<p>The <code>Compiler</code> will hold an IR <code>Builder</code> and a cached LLVM <code>FloatType</code>
representing a <code>double</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Compiler&lt;'ctx&gt; {
    ctx: &amp;'ctx Context,
    logger: Logger,
    builder: Builder,
    double: FloatType,
}
#}</code></pre></pre>
<p>The constructor for <code>Compiler</code> isn't overly exciting:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;'ctx&gt; Compiler&lt;'ctx&gt; {
    pub fn new(ctx: &amp;'ctx Context) -&gt; Compiler&lt;'ctx&gt; {
        Compiler::new_with_logger(ctx, &amp;Logger::root(Discard, o!()))
    }

    pub fn new_with_logger(ctx: &amp;'ctx Context, logger: &amp;Logger) -&gt; Compiler&lt;'ctx&gt; {
        let logger = logger.new(o!(&quot;phase&quot; =&gt; &quot;trans&quot;));

        let double = ctx.f64_type();

        let builder = ctx.create_builder();

        Compiler {
            ctx,
            builder,
            logger,
            double,
        }
    }
}
#}</code></pre></pre>
<a class="header" href="back/index.html#super-basic-compilation" id="super-basic-compilation"><h2>Super Basic Compilation</h2></a>
<p>The compilation process is actually quite simple. We take in an AST and
recursively visit each node, generating the corresponding LLVM IR. To begin
with, we'll hard-code the module to be <code>&quot;calc&quot;</code> and compile our one and only
function.</p>
<p>For this first pass we're going to take several short-cuts (noticeable by the
use of <code>unimplemented!()</code>) so we can get the initial compiler working.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    /// Compile an AST tree to a LLVM `Module`.
    pub fn compile(&amp;self, ast: &amp;Expr) -&gt; Module {
        const CALC_ENTRYPOINT: &amp;'static str = &quot;calc_main&quot;;

        let mut module = self.ctx.create_module(&quot;calc&quot;);

        self.compile_function(&amp;mut module, CALC_ENTRYPOINT, ast);

        module
    }
#}</code></pre></pre>
<p>In LLVM, you create a function by first declaring its signature, then add one or
more basic blocks (contiguous set of instructions without any branching or
jumps). The entry point of every function is typically named <code>&quot;entry&quot;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn compile_function(&amp;self, module: &amp;mut Module, name: &amp;str, body: &amp;Expr) -&gt; FunctionValue {
        // hard-code all functions to be `fn() -&gt; f64`
        let sig = self.double.fn_type(&amp;[], false);
        let func = module.add_function(name, &amp;sig, None);

        let entry = func.append_basic_block(&quot;entry&quot;);
        self.builder.position_at_end(&amp;entry);

        let ret = self.compile_expr(body);

        self.builder.build_return(Some(&amp;ret));

        func
    }
#}</code></pre></pre>
<p>Compiling an <code>Expr</code> is just a case of <code>match</code>ing on the type of expression and
calling the corresponding <code>compile_*()</code> method.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn compile_expr(&amp;self, expr: &amp;Expr) -&gt; FloatValue {
        match *expr {
            Expr::Atom(ref atom) =&gt; self.compile_atom(atom),
            Expr::BinaryOp(ref op) =&gt; self.compile_binary_op(op),
            Expr::FunctionCall(ref call) =&gt; self.compile_function_call(call),
        }
    }
#}</code></pre></pre>
<p>We're not going to worry about variables just yet, so compiling atoms is just
a case of emitting a constant.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn compile_atom(&amp;self, atom: &amp;Atom) -&gt; FloatValue {
        match *atom {
            Atom::Number(n) =&gt; self.double.const_float(n),
            _ =&gt; unimplemented!(),
        }
    }
#}</code></pre></pre>
<p>Compiling a binary op is also fairly straightforward, we need to <code>match</code> on the
type of operation and then use the <code>Builder</code>'s <code>build_float_*()</code> methods to
emit the corresponding LLVM IR.</p>
<p>There's a little twist to this step though. In order to compile a binary
operation we need to give LLVM its two operands. This means we'll need to
recursively call <code>compile_expr()</code> on <code>op.left</code> and <code>op.right</code> before the <code>match</code>
bit.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn compile_binary_op(&amp;self, op: &amp;BinaryOp) -&gt; FloatValue {
        let left = self.compile_expr(&amp;op.left);
        let right = self.compile_expr(&amp;op.right);

        match op.op {
            Op::Add =&gt; self.builder.build_float_add(&amp;left, &amp;right, &quot;add&quot;),
            Op::Subtract =&gt; self.builder.build_float_sub(&amp;left, &amp;right, &quot;sub&quot;),
            Op::Multiply =&gt; self.builder.build_float_mul(&amp;left, &amp;right, &quot;mul&quot;),
            Op::Divide =&gt; self.builder.build_float_div(&amp;left, &amp;right, &quot;div&quot;),
        }
    }
#}</code></pre></pre>
<p>Compiling function calls requires us to do a type-checking pass beforehand, if
you skip type-checking there's a good chance someone will use the wrong number
of parameters and leave the world in an inconsistent state (usually resulting in
a segfault).</p>
<p>Type-checking and symbol table generation will be done in a later chapter, so we
can leave it <code>unimplemented!()</code> for now.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn compile_function_call(&amp;self, call: &amp;FunctionCall) -&gt; FloatValue {
        unimplemented!()
    }
#}</code></pre></pre>
<a class="header" href="back/index.html#testing-the-code-generation" id="testing-the-code-generation"><h2>Testing The Code Generation</h2></a>
<p>So far we can support binary operations and <code>double</code> constants. It's not overly
much, but our <code>calc</code> tool can already do everything a normal desk calculator
can. We just need to ask LLVM to JIT-compile and execute our code.</p>
<p>Once we've parsed the source text into an AST, the JIT-compilation process
consists of:</p>
<ul>
<li>Initialize a <code>Target</code></li>
<li>Create an LLVM <code>Context</code></li>
<li>Compile the AST into a <code>Module</code></li>
<li>Create a JIT execution engine based on the module</li>
<li>Get a pointer to the JIT-compiled <code>calc_main</code> function</li>
<li>Run it</li>
</ul>
<p>While this may sound long and compilicated, it's maybe a dozen lines and one
<code>unsafe</code> block at most.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub type CalcMain = unsafe extern &quot;C&quot; fn() -&gt; f64;

fn execute(src: &amp;str) -&gt; Result&lt;f64, Error&gt; {
    Target::initialize_native(&amp;InitializationConfig::default())?;

    let ast = ::syntax::parse(src)?;
    let ctx = Context::create();
    let module = Compiler::new(&amp;ctx).compile(&amp;ast);

    let ee = module
        .create_jit_execution_engine(OptimizationLevel::None)?;

    unsafe {
        let calc_main = ee.get_function::&lt;CalcMain&gt;(&quot;calc_main&quot;)?;

        Ok(calc_main())
    }
}
#}</code></pre></pre>
<p>While it's not 100% production-ready yet, we can use the above <code>execute()</code>
function to start testing some basic inputs.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn execute_some_binary_ops() {
    let inputs = vec![
        (&quot;1+1&quot;, 2.0),
        (&quot;1-1&quot;, 0.0),
        (&quot;2*4.5&quot;, 9.0),
        (&quot;100.0/3&quot;, 100.0 / 3.0),
    ];

    for (src, should_be) in inputs {
        let got = execute(src).unwrap();
        assert_eq!(got, should_be);
    }
}

#[test]
fn execute_a_more_complex_statement() {
    let src = &quot;5 * (100 + 3) / 9 - 2.5&quot;;
    let should_be = 5.0 * (100.0 + 3.0) / 9.0 - 2.5;

    let got = execute(src).unwrap();
    assert_eq!(got, should_be);
}
#}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="parse/visit.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="parse/visit.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        
        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-78714693-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
